# ------------------------------------------
# SPDX-License-Identifier: MIT OR Apache-2.0
# ------------------------------------------
[env]
_.file = {path = ".config/.env.json", redact = true}
SSH_IP = "{{ exec(command=\"echo $SSH_CLIENT | cut -d' ' -f1\") }}"
SSH_PORT = "{{ exec(command=\"echo $SSH_CLIENT | cut -d' ' -f3\") }}"
PATH_HASH = "{{exec(command=\"echo $PWD | cksum | cut -d' ' -f1\")}}"
SSH_OUT = "~/.local/share/rsync/{{env.PATH_HASH}}"
FEATURES = "{% if env.SSH_IP %}'dev'{% else %}'dev dylib'{% endif %}"
CARGO_TERM_COLOR = "always"

[tools]
"mold" = "latest"
act = "latest"

[tools.rust]
# keep in sync with bevy_cli
version = "nightly-2025-06-26"
components = "rustc-codegen-cranelift-preview,rustc-dev,llvm-tools-preview,clippy"
targets = "x86_64-pc-windows-msvc,x86_64-unknown-linux-gnu"

[tasks.install_bevy_lint]
hide = true
run = """
rustup run nightly-2025-06-26 cargo install \
    --git https://github.com/TheBevyFlock/bevy_cli.git \
    --tag lint-v0.4.0 \
    --locked \
    bevy_lint || true
"""


## CHECKS #####################################################################

[tasks."check:deps"]
alias = "deny"
tools = { "cargo:cargo-deny" = "latest" }
description = "Check dependencies with cargo-deny"
run = """
cargo deny --workspace \
    -L error \
    check advisories bans sources \
    --hide-inclusion-graph
"""

[tasks."check:headers"]
alias = "check-headers"
depends = ["fix:headers --fail-on-fix"]

[tasks.bevy_lint]
hide = true
depends = ["install_bevy_lint"]
run = """
    # bevy_lint

    # TEMP: Disable sccache in ci
    if [ -n $CI ];
        then RUSTC_WRAPPER=""
        else
            RUSTC_WRAPPER="sccache"
            CARGO=$(rustup which --toolchain nightly-2025-06-26 cargo) bevy_lint
    fi
    if [ '{{flag(name="fix")}}' = 'true' ]
        then FIX=" --fix";
    fi

    bevy_lint --locked --all-features \
        $FIX \
        {{arg(name="package", var=true)}};
"""

[tasks.clippy]
hide = true
run = """
# clippy

# TEMP: Disable sccache in ci
if [ -n $CI ];
    then RUSTC_WRAPPER="";
    else RUSTC_WRAPPER="sccache"
fi
if [ '{{flag(name="fix")}}' = 'true' ];
    then FIX=" --fix";
fi

cargo --color=always clippy --locked --all-features \
    $FIX \
    {{arg(name="package", var=true)}};
"""

[tasks.check]
alias = "check-app"
depends = ["clippy -p app", "bevy_lint -p app"]
sources = ["src"]


## FIXES ######################################################################

[tasks."fix:headers"]
alias = "fix-headers"
tools = { "uv" = "latest", "pipx:add_header_comment" = "latest" }
description = "Check file headers"
run = """
# Checking headers

if [ '{{flag(name="fail-on-fix")}}' = 'true' ]
    then FAIL_ON_FIX=" --fail-on-fix";
fi

HEADER_PATH=".config/header.txt"

shopt -s globstar

uv run add-header-comment --header-filepath $HEADER_PATH \
    $FAIL_ON_FIX \
    ./.config/*.toml \
    ./*.toml;

uv run add-header-comment --header-filepath $HEADER_PATH\
    $FAIL_ON_FIX \
    --comment-style='//' \
    src/**/*.rs;
"""

[tasks."fix:rust"]
alias = "fix-rust"
description = "Fix any fixable issues in rust. Includes formatting."
depends = ["check --fix"]

[tasks.fix]
description = "Fix all fixable issues."
depends = ["fix:rust", "fix:headers"]

## BUILD AND DEPLOY ###########################################################

[tasks.ci]
tools = { "act" = "latest" }
description = "Test CI locally with nektos/act"
run = "act -P ubuntu-24.04=ghcr.io/catthehacker/ubuntu:act-24.04 {{arg(name='rest', default='--', var=true)}}"

[tasks.test]
tools = { "cargo:cargo-nextest" = "latest" }
description = "Run tests for a specific package or all packages"
run = """
    RUST_LOG=app=debug cargo nextest run -F dev
fi
"""

# LOCAL #######################################################################

[tasks.run_local]
env = { "RUSTC_WRAPPER" = "sccache" }
tools = { "sccache" = "latest" }
run = "cargo run --bin {{arg(name='binary', default='app')}} {{arg(name='rustc-opts', var=true, default='--')}}"

[tasks.build_local]
env = { "RUSTC_WRAPPER" = "sccache" }
tools = { "sccache" = "latest" }
run = "cargo build --features {{env.FEATURES}} --bin {{arg(name='binary', default='app')}} {{arg(name='rustc-opts', var=true, default='--')}}"

[tasks.play_local]
run = "cargo run --bin app {{arg(name='inputs', var=true, default='-F dev')}}"


# SSH #########################################################################

# The idea with this section is to sync files using a server/client protocol.
# The server then opens the app at the specified path, assuming it has the right
# auth. Ideally, we would just use a game stream host like Moonlight/Sunshine
# instead, but my GPU isn't strong enough for that.

[tasks.rsync]
run = """
if [ -n "SSH_IP" ]; then
    rsync -avzr --progress --mkpath \
        ./assets \
        ./target/debug/{{arg(name="bin", default="app")}} \
        "$SSH_IP:$SSH_OUT"
fi
"""

[tasks.run_ssh]
depends = ["rsync"]
run = """
if [ -n "SSH_IP" ]; then
    curl $SSH_IP:9995 -sd '{"auth": "{{env.auth}}", "path": "{{env.SSH_OUT}}/{{arg(name="bin", default="app")}}"}'
fi
"""

# LOCAL #######################################################################

[tasks.run]
description = "Run the specified workspace binary"
raw = true
run = """
#!/usr/bin/bash
if [ -z "$SSH_CLIENT" ]
    then mise run_local
    else mise -j1 build_local ::: run_ssh {{arg(name="bin", default="app")}}
fi
"""

[tasks.build]
description = "Build the specified workspace binary"
raw = true
run = """
#!/usr/bin/bash
if [ -z "$SSH_CLIENT" ]
    then mise build_local
    else mise -j1 build_local ::: rsync
fi
"""


[tasks.play]
description = "Play the game"
raw = true
run = """
#!/usr/bin/bash
if [ -z "$SSH_CLIENT" ]
    then mise play_local
    else mise -j1 build_local ::: run_ssh
fi
"""

[tasks.new]
raw=true
alias=['generate', 'n']
description="Generate a new service or screen."
tools={"cargo:cargo-generate" = "latest"}
usage = '''
arg "<template>" help="The template to generate." {
    choices "screen" "service"
}

arg "<name>" help="Name of the generated module." long_help="""
The chosen template will be output to the src directory corresponding to the
template, postfixed with given template name. For example, calling
'mise new service foo/bar' will generate 'src/service/foo/bar/...'.
"""

flag "--debug" help="Enable debug output."
'''
run='''
#!/usr/bin/bash
TEMPLATE=${usage_template?}
NAME=${usage_name?}
DEBUG=${usage_debug:+--debug}

BASENAME=$(basename $NAME)
DESTINATION="$(realpath src/$TEMPLATE/$(dirname $NAME))"

if [[ -n "$DEBUG" ]]; then
cat <<EOF
DEBUG
TEMPLATE="$TEMPLATE"
NAME="$NAME"
BASENAME="$BASENAME"
DESTINATION="$DESTINATION"
EOF
fi

catch_err () {
    if [ $? -ne 0 ]; then
        echo "Reverting changes on fail..."
        set -x
        git restore $DESTINATION/mod.rs
        rm $DESTINATION/$BASENAME -r
        exit 1
    fi
}

cargo generate \
    --name "$BASENAME" \
    -d name="$BASENAME" \
    --path ".config/templates/$TEMPLATE" \
    --destination "$DESTINATION";

catch_err

uv run .config/scripts/new_mod/main.py\
    "$DESTINATION/$BASENAME"\
    "$DEBUG"

catch_err

echo "[INFO] Formatting ..."
cargo fmt -- -l;
'''

[tasks.delete]
alias=['del', 'd']
description="Remove a generated service or screen"
usage = '''
arg "<template>" help="The template to remove." {
    choices "screen" "service"
}

arg "<name>" help="Name of the generated module." long_help="""
The chosen template will be removed from the src directory corresponding to the
template, postfixed with given template name. For example, calling
'mise new service foo/bar' will generate 'src/service/foo/bar/...'.
"""

flag "--debug" help="Enable debug output."
'''
run='''
#!/usr/bin/bash
set -e
TEMPLATE=${usage_template?}
NAME=${usage_name?}
DESTINATION="$(realpath src/$TEMPLATE/$NAME)"
DEBUG=${usage_debug:+--debug}

uv run .config/scripts/new_mod/main.py\
    "$DESTINATION" \
    --remove \
    $DEBUG

set -x
rm -r $DESTINATION
set +x

echo "[INFO] Formatting ..."
cargo fmt -- -l;
'''
