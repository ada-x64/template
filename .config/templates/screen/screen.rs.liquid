{%- assign settings_name = name | upper_camel_case | append: "Settings" -%}
{%- assign screen_name = name | upper_camel_case | append: "Screen" -%}
use crate::prelude::*;

{% if pedantic -%}
/// This screen's settings. Can also be replaced with [EmptyScreenSettings] if desired.
/// This struct can be used to dynamically change the screen's behavior.
{%- endif %}
#[derive(PartialEq, Eq, Clone, Debug, Hash, Reflect, Default, Resource)]
pub struct {{settings_name -}};

{% if pedantic -%}
/// The main [Screen] implementation.
{%- endif %}
#[derive(Component, Debug, Clone, Copy, Default, PartialEq, Eq, Hash)]
pub struct {{screen_name -}};
impl Screen for {{screen_name}} {
    {% if pedantic -%}
    /// Note: This can be replaced with EmptyScreenSettings
    {%- endif %}
    type SETTINGS = {{settings_name -}};
    const NAME: ScreenType = Screens::{{- name | upper_camel_case -}}.as_screen_type();

    {% if pedantic -%}
    /// Use this function to initialize your screen, e.g. by calling commands
    /// or scoping observers.
    {%- endif %}
    fn init<'w>(mut world: DeferredWorld<'w>, _ctx: HookContext) {
        let settings = world.resource::<Self::SETTINGS>().clone();
        // ...
    }

    {% if pedantic -%}
    /// Use this optional function to handle any unloading logic, e.g.
    /// despawning entities, serializing state, etc.
    fn unload() -> impl System<In = (), Out = ()> {
        IntoSystem::into_system(|| {})
    }
    {%- endif %}
}

pub fn plugin(app: &mut App) {
    {% if pedantic -%}
    // Used `fixed` to hook into the fixed schedule and `default` to hook into
    // the main schedule.
    {%- endif %}
    ScreenScopeBuilder::<{{screen_name}}>::fixed()
    {% if pedantic -%}
        // add systems here ...
        // .add_systems(player_systems().take())
        // .add_systems(tracking_cam_systems().take())
    {%- endif %}
        .build(app);
}
