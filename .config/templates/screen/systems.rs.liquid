{%- assign schedule_name = name | upper_camel_case | append: "Schedule" -%}
{%- assign screen_name = name | upper_camel_case | append: "Screen" -%}
use crate::prelude::*;
use bevy::ecs::{component::HookContext, schedule::ScheduleLabel, world::DeferredWorld};

/// This screen's [Schedule]. All systems added to this schedule, using the
/// [ScreenScope] below, will be scoped to this screen's lifetime. That is,
/// they will only run when the screen is in [ScreenStatus::Ready].
#[derive(ScheduleLabel, SystemSet, Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum {{schedule_name}} {
    Update,
    FixedUpdate,
}

/// The main [Screen] implementation.
#[derive(Component, Debug, Clone, Copy, Default)]
pub struct {{screen_name -}};

impl Screen for {{screen_name}} {
    /// Use this optional function to initialize your screen, e.g. by calling commands
    /// or scoping observers.
    fn init<'w>(_world: &mut DeferredWorld<'w>, _ctx: &HookContext) {}

    /// Use this optional function to handle any unloading logic, e.g.
    /// despawning entities, serializing state, etc.
    /// (Note: In most cases, you should scope entities by using the
    /// [ScreenScoped] component)
    fn unload(_world: &mut World) {}
}

pub fn plugin(app: &mut App) {
    ScreenScope::<{{screen_name}}>::default()
        .builder(
            {{schedule_name -}}::FixedUpdate,
            Screens::{{- name | upper_camel_case -}}(ScreenStatus::Ready),
        )
        // .add_systems(player_systems().take())
        // .add_systems(tracking_cam_systems().take())
        .build_fixed(app);
}
