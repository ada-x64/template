use crate::prelude::*;
use bevy::ecs::schedule::ScheduleLabel;
use std::marker::PhantomData;

/// A type-erased way to store the current screen. Generated by calling
/// [bevy::reflect::enum_hash] on the screen enum variant.
#[derive(Deref, DerefMut, Copy, Clone, Debug, PartialEq, Eq, Hash, Reflect)]
pub struct ScreenType(pub u64);
impl From<u64> for ScreenType {
    fn from(value: u64) -> Self {
        Self(value)
    }
}

/// Stores the current [ScreenType], which is a type-erased hash of the current screen enum.
#[derive(States, Debug, PartialEq, Eq, Reflect, Hash, Clone, Deref)]
pub struct CurrentScreen(pub ScreenType);
impl From<ScreenType> for CurrentScreen {
    fn from(value: ScreenType) -> Self {
        Self(value)
    }
}

/// Type-erased version of [ScreenLoadingState] for general-purpose use.
/// Reflects the loading status of the [CurrentScreen].
#[derive(Default, States, Debug, PartialEq, Eq, Reflect, Hash, Clone, Copy, Deref)]
pub struct CurrentScreenStatus(pub ScreenStatus);
impl From<ScreenStatus> for CurrentScreenStatus {
    fn from(value: ScreenStatus) -> Self {
        Self(value)
    }
}

/// Stores next [Screens] state for unload logic.
#[derive(Resource, Default)]
pub struct NextScreen(pub Option<ScreenType>);

/// Triggered when a [Screen] finishes unloading and is
/// ready to transition.
#[derive(Event, Debug, PartialEq, Eq, Clone, Copy)]
pub struct FinishUnload;

/// Call this when you want to switch screens.
#[derive(Event, Debug, PartialEq, Eq, Clone, Deref)]
pub struct SwitchToScreen(pub ScreenType);

/// Enumerates possible screen states.
#[derive(PartialEq, Eq, Hash, Debug, Clone, Copy, Reflect, Default)]
pub enum ScreenStatus {
    #[default]
    Loading,
    Ready,
    Unloading,
}

/// An empty settings parameter.
#[derive(Resource, Default)]
pub struct EmptySettings;

/// An empty [AssetCollection]. Used to bypass loading.
#[derive(Resource, Default, AssetCollection)]
pub struct EmptyAssetCollection {}

/// A screen's [Schedule]. All systems added to this schedule, using the
/// [ScreenScope] below, will be scoped to this screen's lifetime. That is,
/// they will only run when the screen is in [ScreenStatus::Ready].
#[allow(bevy::unconventional_naming)]
#[derive(ScheduleLabel, SystemSet, Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum ScreenScope<T: Screen> {
    _Ghost(PhantomData<T>),
    Main,
    Fixed,
}

/// [State] for a [Screen] to be used as the type parameter for [LoadingState].
/// See the [bevy_asset_loader] docs for more info on how asset loading works.
/// For a type erased version of this enum, see [CurrentScreenStatus].
#[derive(States, Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub enum ScreenLoadingState<T: Screen> {
    #[default]
    Unloaded,
    Loading,
    Ready,
    Unloading,
    _Phantom(PhantomData<T>),
}
impl<T: Screen> ScreenLoadingState<T> {
    pub fn is_ready(&self) -> bool {
        matches!(self, Self::Ready)
    }
    pub fn is_loading(&self) -> bool {
        matches!(self, Self::Loading)
    }
    pub fn is_unloading(&self) -> bool {
        matches!(self, Self::Unloaded)
    }
    pub fn is_unloaded(&self) -> bool {
        matches!(self, Self::Unloaded)
    }
}

/// Scopes an entity to the current screen. The entity will be cleaned up when
/// the [Screens] state changes. By default, all entities _except_ those listed
/// in the [module documentation](crate::framework::screen) are screen-scoped.
///
/// Note: This is effectively used to stop the downward propagation of the
/// [Persistent] component. Since screen scoping is the default behavior, it
/// should not be necessary to add this component in other cases.
#[derive(Component, Debug, Reflect, Clone, Copy, Default, PartialEq)]
pub struct ScreenScoped;

/// Marks an entity as screen-persistent, i.e., this entity will _not_ be
/// automatically cleaned up when the screen changes. By default, all entites
/// _except_ those listed in the [module
/// documentation](crate::framework::screen) are screen-scoped.
///
/// In order to mark the children of this component as Persistent, you should
/// use the [Propagate] component.
#[derive(Component, Debug, Reflect, Clone, Copy, Default, PartialEq)]
pub struct Persistent;
