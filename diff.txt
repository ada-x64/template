Modified regular file .config/mise.toml:
    ...
   7    7: SSH_PORT = "{{ exec(command=\"echo $SSH_CLIENT | cut -d' ' -f3\") }}"
   8    8: PATH_HASH = "{{exec(command=\"echo $PWD | cksum | cut -d' ' -f1\")}}"
   9    9: SSH_OUT = "~/.local/share/rsync/{{env.PATH_HASH}}"
  10     : BUILD_FLAGS = "{% if env.SSH_IP %}-Fdev{% else %}-Fdev -Fdylib{% endif %}"
       10: FEATURES = "{% if env.SSH_IP %}'dev'{% else %}'dev dylib'{% endif %}"
  11   11: CARGO_TERM_COLOR = "always"
  12   12: 
  13   13: [tools]
    ...
 160  160: [tasks.build_local]
 161  161: env = { "RUSTC_WRAPPER" = "sccache" }
 162  162: tools = { "sccache" = "latest" }
 163  163: run = "cargo build --features {{env.BUILD_FLAGSFEATURES}} --bin {{arg(name='binary', default='app')}} {{arg(name='rustc-opts', var=true, default='--')}}"
 164  164: 
 165  165: [tasks.play_local]
 166  166: run = "cargo run --bin app {{arg(name='inputs', var=true, default='-F dev')}}"
 167  167: 
 168  168: [tasks.dev_local]
      169: raw = true
 169  170: run = "BEVY_ASSET_ROOT='.' dx serve --hot-patch --features {{env.BUILD_FLAGSFEATURES}}"
 170  171: 
 171  172: 
 172  173: # SSH #########################################################################
    ...
Modified regular file Cargo.lock:
    ...
 220  220:  "itertools 0.14.0",
 221  221:  "iyes_perf_ui",
 222  222:  "serde",
      223:  "strum 0.27.2",
 223  224:  "thiserror 2.0.16",
 224  225:  "tiny_bail",
 225  226: ]
    ...
3980 3981:  "pp-rs",
3981 3982:  "rustc-hash 1.1.0",
3982 3983:  "spirv",
3983 3984:  "strum 0.26.3",
3984 3985:  "termcolor",
3985 3986:  "thiserror 2.0.16",
3986 3987:  "unicode-xid",
    ...
5628 5629: source = "registry+https://github.com/rust-lang/crates.io-index"
5629 5630: checksum = "8fec0f0aef304996cf250b31b5a10dee7980c85da9d759361292b8bca5a18f06"
5630 5631: dependencies = [
5631 5632:  "strum_macros 0.26.4",
     5633: ]
     5634: 
     5635: [[package]]
     5636: name = "strum"
     5637: version = "0.27.2"
     5638: source = "registry+https://github.com/rust-lang/crates.io-index"
     5639: checksum = "af23d6f6c1a224baef9d3f61e287d2761385a5b88fdab4eb4c6f11aeb54c4bcf"
     5640: dependencies = [
5631 5641:  "strum_macros 0.27.2",
5632 5642: ]
5633 5643: 
5634 5644: [[package]]
    ...
5645 5655: ]
5646 5656: 
5647 5657: [[package]]
     5658: name = "strum_macros"
     5659: version = "0.27.2"
     5660: source = "registry+https://github.com/rust-lang/crates.io-index"
     5661: checksum = "7695ce3845ea4b33927c055a39dc438a45b059f7c1b3d91d38d10355fb8cbca7"
     5662: dependencies = [
     5663:  "heck",
     5664:  "proc-macro2",
     5665:  "quote",
     5666:  "syn",
     5667: ]
     5668: 
     5669: [[package]]
5648 5670: name = "subsecond"
5649 5671: version = "0.7.0-rc.0"
5650 5672: source = "registry+https://github.com/rust-lang/crates.io-index"
    ...
Modified regular file Cargo.toml:
    ...
  64   64: serde = { version = "1.0.219", features = ["derive"] }
  65   65: anyhow = "1.0.99"
  66   66: bevy_rich_text3d = "0.4.2"
       67: strum = { version = "0.27.2", features = ["derive"] }
  67   68: 
  68   69: [features]
  69   70: dev = [
    ...
Added regular file diff.txt:
    (empty)
Modified regular file src/dev/gizmos.rs:
   1    1: // ------------------------------------------
   2    2: // SPDX-License-Identifier: MIT OR Apache-2.0
   3    3: // ------------------------------------------
   4    4: use avian3d::prelude::{PhysicsDebugPlugin, PhysicsGizmos};
   5    5: use bevy::{color::palettes::css::*, prelude::*, render::view::RenderLayers};
   6    6: 
   7    7: use crate::{
   7    8:     data::RenderLayer,
        9:     prelude::{FlyCam, PlayerCam, PlayerCamController, PlayerController},
   7   10: };
   8   11: 
   9   12: pub fn plugin(app: &mut App) {
  10   13:     app.add_plugins(PhysicsDebugPlugin::default())
    ...
  23   26:                 enabled: false,
  24   27:                 ..Default::default()
  25   28:             },
  26   29:         );
       30:         .insert_gizmo_config(
       31:             CameraGizmoConfigGroup::default(),
       32:             GizmoConfig {
       33:                 render_layers: RenderLayers::from(RenderLayer::GIZMOS_3D),
       34:                 enabled: true,
       35:                 line: GizmoLineConfig {
       36:                     style: GizmoLineStyle::Dashed {
       37:                         gap_scale: 1.,
       38:                         line_scale: 1.,
       39:                     },
       40:                     ..Default::default()
       41:                 },
       42:                 ..Default::default()
       43:             },
       44:         )
       45:         .add_systems(Update, render_camera_gizmos);
       46: }
       47: 
       48: #[derive(GizmoConfigGroup, Reflect)]
       49: pub struct CameraGizmoConfigGroup {
       50:     pub radius: f32,
       51:     pub fly_cam_color: Color,
       52:     pub player_cam_color: Color,
       53:     pub render_player_cam_spheres: bool,
       54:     pub player_cam_sphere_color: Color,
       55: }
       56: impl Default for CameraGizmoConfigGroup {
       57:     fn default() -> Self {
       58:         Self {
       59:             radius: 1.,
       60:             fly_cam_color: RED.into(),
       61:             player_cam_color: LIGHT_BLUE.into(),
       62:             render_player_cam_spheres: true,
       63:             player_cam_sphere_color: YELLOW.into(),
       64:         }
       65:     }
       66: }
       67: 
       68: fn render_camera_gizmos(
       69:     mut cam_gizmos: Gizmos<CameraGizmoConfigGroup>,
       70:     config_store: Res<GizmoConfigStore>,
       71:     fly_cam: Query<&Transform, With<FlyCam>>,
       72:     player_cam: Query<(&Transform, &PlayerCamController), With<PlayerCam>>,
       73:     player_tf: Query<&Transform, With<PlayerController>>,
       74: ) {
       75:     let config = config_store.config::<CameraGizmoConfigGroup>().1;
       76:     if let Ok(tf) = fly_cam.single() {
       77:         cam_gizmos.sphere(tf.to_isometry(), config.radius, config.fly_cam_color);
       78:     }
       79:     if let Ok((tf, controller)) = player_cam.single() {
       80:         cam_gizmos.sphere(tf.to_isometry(), config.radius, config.player_cam_color);
       81:         if let Ok(tf) = player_tf.single()
       82:             && config.render_player_cam_spheres
       83:         {
       84:             cam_gizmos.sphere(
       85:                 tf.to_isometry(),
       86:                 controller.inner_radius,
       87:                 config.player_cam_sphere_color,
       88:             );
       89:             cam_gizmos.sphere(
       90:                 tf.to_isometry(),
       91:                 controller.outer_radius,
       92:                 config.player_cam_sphere_color,
       93:             );
       94:         }
  26   95:     }
  27   96: }
Modified regular file src/dev/minibuffer/actions/in_world.rs:
    ...
   4    4: use avian3d::prelude::PhysicsGizmos;
   5    5: use bevy::prelude::*;
   6    6: use bevy_minibuffer::prelude::*;
        7: use std::str::FromStr;
        8: use strum::{Display, EnumString, VariantNames};
   7    9: 
   8   10: use crate::{
   9   11:     dev::minibuffer::fly_cam::FlyCam, screens::ScreenStates, services::player::data::PlayerCam,
  10   12: };
  11   13: 
  12     : fn toggle_flycam(
  13   14:     #[derive(Debug, Display, VariantNames, EnumString)]
       15: enum Cameras {
       16:     FlyCam,
       17:     PlayerCam,
       18: }
       19: 
       20: fn set_camera_controller() {}
       21: 
       22: fn cycle_cam() {}
       23: 
  13   24: fn set_cam(state: Res<State<ScreenStates>>,
  14   24:     mut set: ParamSet<(
  15     :         Single<&mut Camera, With<FlyCam>>,
  16     :         Option<Single<&mut Camera, With<PlayerCam>>>,
  17     :     )>,
  18   24:     mut minibuffer: Minibuffer,
  19   24: ) {
  20   25:     if !matches!(**state, ScreenStates::InWorld) {
  21     :         set.p0().is_active = false;
       26:         minibuffer.message("This command requires ScreenStates::InWorld");
  22   27:         return;
  23   28:     }
  24     :     let prev_state = set.p0().is_active;
  25     :     set.p0().is_active = !prev_state;
  26     :     if let Some(mut cam) = set.p1() {
  27     :         cam.is_active = prev_state;
  28     :     }
  29     :     if prev_state {
  30     :         minibuffer.message("Returning to main camera.")
  31     :     } else {
  32     :         minibuffer.message("Using dev flycam.")
  33     :     }
       29:     minibuffer
       30:         .prompt_map("Which camera?", Cameras::VARIANTS.to_vec())
       31:         .observe(
       32:             |mut trigger: Trigger<Submit<String>>,
       33:              mut set: ParamSet<(
       34:                 Option<Single<&mut Camera, With<FlyCam>>>,
       35:                 Option<Single<&mut Camera, With<PlayerCam>>>,
       36:             )>,
       37:              mut minibuffer: Minibuffer| {
       38:                 if let Ok(val) = trigger.event_mut().take_result() {
       39:                     match Cameras::from_str(&val).unwrap() {
       40:                         Cameras::FlyCam => {
       41:                             set.p0().unwrap().is_active = true;
       42:                             set.p1().unwrap().is_active = false;
       43:                         }
       44:                         Cameras::PlayerCam => {
       45:                             set.p0().unwrap().is_active = false;
       46:                             set.p1().unwrap().is_active = true;
       47:                         }
       48:                     }
       49:                     minibuffer.message(format!("Set camera to {val}"));
       50:                 } else {
       51:                     minibuffer.message("Cancelled.");
       52:                 }
       53:             },
       54:         );
  34   55: }
  35   56: 
  36   57: fn toggle_gizmos<T: GizmoConfigGroup>(mut g: ResMut<GizmoConfigStore>, mut minibuffer: Minibuffer) {
    ...
  45   66: 
  46   67: pub fn plugin(app: &mut App) {
  47   68:     app.add_acts((
  48   69:         Act::new(toggle_flycamset_cam).bind(vec![KeyCode::Space, KeyCode::Space]),
  49   70:         // TODO could use Askyy prompts here
  50   71:         Act::new(toggle_gizmos::<PhysicsGizmos>).named("toggle_physics_gizmos"),
  51   72:         Act::new(toggle_gizmos::<LightGizmoConfigGroup>).named("toggle_light_gizmos"),
    ...
Added regular file src/services/data.rs:
        1: use std::ops::BitOr;
        2: 
        3: use crate::prelude::*;
        4: use avian3d::prelude::*;
        5: 
        6: #[derive(PhysicsLayer, Copy, Clone, Debug, Default)]
        7: pub enum CollisionLayer {
        8:     #[default]
        9:     Default,
       10:     Player,
       11:     Camera,
       12: }
       13: impl BitOr for CollisionLayer {
       14:     type Output = u32;
       15: 
       16:     fn bitor(self, rhs: Self) -> Self::Output {
       17:         self.to_bits() | rhs.to_bits()
       18:     }
       19: }
Modified regular file src/services/input/cursor.rs:
    ...
  11   11:     mut window: Single<&mut Window>,
  12   12:     mut commands: Commands,
  13   13:     ictx_cam_default: Query<
       14:         // TODO: Replace with generic CameraController so we can toggle controllers separately from views
  14   15:         (Entity, &Camera),
  15   16:         (
  16   17:             With<ContextActivity<ICtxCamDefault>>,
    ...
Modified regular file src/services/mod.rs:
   1    1: // ------------------------------------------
   2    2: // SPDX-License-Identifier: MIT OR Apache-2.0
   3    3: // ------------------------------------------
        4: pub(crate) mod data;
   4    5: pub(crate) mod input;
   5    6: pub(crate) mod player;
   6    7: pub(crate) mod ui;
    ...
Modified regular file src/services/player/camera.rs:
   1     : use avian3d::math::PI;
   2     : 
   3    1: // ------------------------------------------
   4    2: // SPDX-License-Identifier: MIT OR Apache-2.0
   5    3: // ------------------------------------------
   6    4: use crate::{prelude::*;, services::data::CollisionLayer};
        5: use avian3d::{math::PI, prelude::*};
        6: 
        7: // The idea:
        8: // Minimum and maximum distance spheres.
        9: // The camera tries to maintain the maximum distance,
       10: // but collisions with physics objects will move the camera towards the minimum distance sphere.
       11: // The camera _cannot_ clip through the minimum distance sphere and will maintain at least that much distance.
       12: // Zoom = changing outer sphere radius.
       13: // No need for colliders, could just cast a single ray from the player to the desired camera position.
   6   14: // If there is a collision, then (smoothly) move to the collisions location.
   7   15: 
   8   16: fn spawn_cam_actions(event: Trigger<OnAdd, ICtxCamDefault>, mut commands: Commands) {
   9     :     info!("spawn_cam_actions");
  10   17:     commands.entity(event.target()).insert(actions![
  11   18:         ICtxCamDefault[
  12   19:         (
    ...
  38   45:     trigger: Trigger<Fired<PARotateCam>>,
  39   46:     mut controller: Query<&mut PlayerCamController>,
  40   47: ) {
  41     :     debug!("Got rotatation trigger! value={}", trigger.value);
  42   48:     let mut controller = controller.get_mut(trigger.target()).unwrap();
  43   49:     controller.rotation.x = (controller.rotation.x + trigger.value.x) % (2. * PI);
       50:     controller.rotation.y = (controller.rotation.y + trigger.value.y).clamp(-PI / 8., 1. * PI / 8.);
  44   51: }
  45   52: 
  46   53: fn on_zoom(trigger: Trigger<Fired<PAZoomCam>>, mut controller: Query<&mut PlayerCamController>) {
  47     :     debug!("Got zoom trigger! value={}", trigger.value);
  48   54:     let mut controller = controller.get_mut(trigger.target()).unwrap();
  49     :     controller.zoom = f32::clamp(
  50     :         controller.zoom + trigger.value,
  51     :         controller.min_zoom,
  52     :         controller.max_zoom,
  53     :     );
       55:     controller.zoom = f32::clamp(controller.zoom + trigger.value, 0., 1.);
  54   56: }
  55   57: 
  56   58: #[cfg_attr(feature = "dev", hot)]
  57   59: fn camera_controlsapply(
  58   60:     pt: Single<&Transform, (With<PlayerController>, Without<PlayerCam>)>,
  59   61:     mut ct: Single<(&mut Transform, &mut PlayerCamController), Without<PlayerController>>,
       62:     mut caster_q: Single<(&mut RayCaster, &RayHits)>,
  60   63:     window: Single<&Window>,
  61   64: ) {
  62   65:     use bevy::window::CursorGrabMode;
  63   66:     // do this, but also disable ctx when flycam is enabled
  64   67:     if window.cursor_options.grab_mode != CursorGrabMode::Locked {
  65   68:         return;
  66   69:     }
       70:     let (ref mut caster, hits) = *caster_q;
  67   71:     let (ref mut ct, ref mut controller) = *ct;
       72: 
       73:     // set desired position
  68   74:     **ct = **pt;
  69     :     ct.rotation = Quat::from_axis_angle(Vec3::Y, controller.rotation);
  70     :     ct.translation = pt.translation + ct.rotation * (Vec3::new(0., 5., 10.) / controller.zoom);
       75:     let rotation = Quat::from_axis_angle(Vec3::Y, controller.rotation.x)
       76:         * Quat::from_axis_angle(Vec3::X, controller.rotation.y);
       77:     let max_dist = hits
       78:         .as_slice()
       79:         .first()
       80:         .map(|d| d.distance)
       81:         .unwrap_or(caster.max_distance);
       82:     ct.translation = pt.translation + rotation * (Vec3::new(0., 5., 5.) * max_dist);
  71   83:     ct.look_at(pt.translation, Vec3::Y);
       84: 
       85:     // set up ray for next pass
       86:     caster.origin = pt.translation;
       87:     let dir = rotation * Vec3::ONE;
       88:     caster.direction = Dir3::new(dir).unwrap();
       89:     caster.max_distance = controller.outer_radius * controller.zoom;
  72   90: }
  73   91: 
  74   92: pub fn plugin(app: &mut App) {
  75   93:     app.add_systems(FixedUpdate, (camera_controlsapply).chain().in_set(PlayerSystems))
  76   94:         .add_input_context::<ICtxCamDefault>()
  77   95:         .add_observer(spawn_cam_actions)
  78   96:         .add_observer(on_zoom)
    ...
Modified regular file src/services/player/controller.rs:
   1     : use avian3d::prelude::LinearVelocity;
   2    1: // ------------------------------------------
   3    2: // SPDX-License-Identifier: MIT OR Apache-2.0
   4    3: // ------------------------------------------
    ...
  35   34: 
  36   35:     let yaw = cam_tf.rotation.to_euler(EulerRot::YXZ).0;
  37   36:     let yaw_quat = Quat::from_axis_angle(Vec3::Y, yaw);
       37:     let moved = controller.last_move.is_some();
  38   38:     let last_move = controller.last_move.take().unwrap_or_default();
  39   39:     let desired_velocity = yaw_quat * last_move;
  40   40:     let desired_forward = moved
  40   41:         .then_some(Dir3::new(-desired_velocity.normalize()).ok())
  40   42:         .flatten();
  41   43: 
  42   44:     tnua.basis(TnuaBuiltinWalk {
  43   45:         desired_velocity: yaw_quat * last_move,
    ...
Modified regular file src/services/player/data.rs:
    ...
  17   17: pub struct SpawnPlayerRoot;
  18   18: 
  19   19: #[derive(Component, Debug, Default)]
       20: #[require(Name::new("PlayerCam"))]
  20   21: pub struct PlayerCam;
  21   22: 
  22   23: #[derive(Component, Default)]
       24: #[require(Name::new("PlayerController"))]
  23   25: pub struct PlayerController {
  24   26:     pub last_move: Option<Vec3>,
  25   27: }
  26   28: 
  27   29: #[derive(Component, Debug)]
  27   30: #[require(Name::new("PlayerCamController"))]
  28   31: pub struct PlayerCamController {
  29     :     pub rotation: f32, // radians
  30     :     pub zoom: f32,     // percentage
  31     :     pub max_zoom: f32,
  32     :     pub min_zoom: f32,
       32:     /// In radians.
       33:     pub rotation: Vec2,
       34:     /// percentage zoomed out (e.g. value of 1 means outer_radius is at 100% its default length)
       35:     pub zoom: f32,
       36:     /// radius of outer sphere. used for zoom and camera collisions.
       37:     pub outer_radius: f32,
       38:     /// radius of inner sphere. used for zoom and camera collisions.
       39:     pub inner_radius: f32,
       40:     /// Desired translation.
       41:     pub desired_tl: Vec3,
  33   42: }
  34   43: impl Default for PlayerCamController {
  35   44:     pub fn defaultnew(desired_tl: Vec3) -> Self {
  36   45:         Self {
  37   46:             rotation: 0.Vec2::ZERO,
  38   47:             zoom: 1.,
  39     :             max_zoom: 20.,
  40     :             min_zoom: 0.1,
       48:             outer_radius: 10.,
       49:             inner_radius: 1.,
       50:             desired_tl,
  41   51:         }
  42   52:     }
  43   53: }
    ...
Modified regular file src/services/player/mod.rs:
    ...
   6    6: pub(crate) mod controller;
   7    7: pub(crate) mod data;
   8    8: 
   9    9: use crate::{data::*, services::data::CollisionLayer};
  10   10: use avian3d::prelude::*;
  11   11: use bevy::{prelude::*, render::view::RenderLayers};
  12   12: use bevy_enhanced_input::prelude::ContextActivity;
    ...
  28   28:     mut commands: Commands,
  29   29:     player_assets: Res<PlayerAssets>,
  30   30: ) {
       31:     // TODO: Should be from terrain height.
       32:     let player_tl = Vec3::new(0., 10., 0.);
       33:     let cam_tl = player_tl + Vec3::new(0., 5., 5.);
       34:     let player_tf = Transform::from_translation(player_tl);
       35:     let cam_tf = Transform::from_translation(cam_tl);
  31   36:     commands.spawn((
  32     :         Name::new("Player Controller"),
  33     :         Transform::from_xyz(0., 10., 0.), // TODO: Should be set relative to terrain
  34     :         StateScoped(ScreenStates::InWorld),
  35   37:         PlayerController::default(),
       38:         StateScoped(ScreenStates::InWorld),
  36   39:         RigidBody::Dynamic,
  37   40:         Collider::capsule(PLAYER_CAPSULE_RADIUS, PLAYER_CAPSULE_HEIGHT),
  38   41:         TnuaController::default(),
  39   42:         TnuaAvian3dSensorShape(Collider::cylinder(PLAYER_CAPSULE_RADIUS + 0.1, 0.)),
  40   43:         LockedAxes::ROTATION_LOCKED.unlock_rotation_y(),
  41   44:         Friction::ZERO,
  42     :         SceneRoot(player_assets.model.clone()),
  43   45:         ICtxDefault,
  44   46:         ContextActivity::<ICtxDefault>::ACTIVE,
       47:         SceneRoot(player_assets.model.clone()),
  45   48:     ));
       49:     commands.spawn((RayCaster::new(
       50:         player_tf.translation,
       51:         Dir3::new((cam_tl - player_tl).normalize()).unwrap(),
       52:     )
       53:     .with_query_filter(SpatialQueryFilter::from_mask(
       54:         CollisionLayer::Camera | CollisionLayer::Default,
       55:     ))
       56:     .with_max_hits(1),));
  46   57:     commands.spawn((
  47   58:         Name::new("PlayerCamPlayerCamRoot"),
  48   59:         PlayerCam,(
  49   60:             PlayerCamController::defaultnew(cam_tl),
  50   61:             cam_tf,
       62:             ICtxCamDefault,
       63:             ContextActivity::<ICtxCamDefault>::ACTIVE,
       64:             LockedAxes::new().lock_rotation_z(),
       65:         ),
       66:         (
       67:             PlayerCam,
  50   68:             StateScoped(ScreenStates::InWorld),
  51   69:         Transform::from_xyz(0., 10., 5.),
  52   69:         Camera3d::default(),
  53   70:         PointLight::default(),
  54   70:         #[cfg(feature = "dev")]
  55   71:             ShowLightGizmo::default(),
  56   72:             PointLight::default(),
  56   73:             Camera {
  57   74:                 is_active: true,
  57   75:                 order: CameraOrder::World.into(),
  58   76:                 ..Default::default()
  59   77:             },
  60   78:             RenderLayers::from(
  60   79:                 RenderLayer::DEFAULT | RenderLayer::GIZMOS_3D | RenderLayer::PARTICLES),
  61   80:         ICtxCamDefault    ),
  62   81:         ContextActivity::<ICtxCamDefault>::ACTIVE),
  63   82:     ));
  64   83: }
  65   84: 
    ...
